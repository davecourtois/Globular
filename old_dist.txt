	
	
	// I will set the docker file depending of the arch.
	var dockerfile string
	if runtime.GOARCH == "amd64" {
		data, err := ioutil.ReadFile("Dockerfile_amd64")
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		dockerfile = string(data)
	} else if runtime.GOARCH == "arm64" {
		data, err := ioutil.ReadFile("Dockerfile_arm64")
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		dockerfile = string(data)
	}

	Utility.CreateDirIfNotExist(path)

	dir, _ := filepath.Abs(filepath.Dir(os.Args[0]))

	// Here I will copy the proxy.
	globularExec := os.Args[0]
	if runtime.GOOS == "windows" && !strings.HasSuffix(globularExec, ".exe") {
		globularExec += ".exe" // in case of windows
	}

	err := Utility.Copy(dir+"/"+globularExec, path+"/"+globularExec)
	if err != nil {
		fmt.Println(err)
	}

	err = os.Chmod(path+"/"+globularExec, 0755)
	if err != nil {
		fmt.Println(err)
	}

	// Copy the bin file from globular
	log.Println(path + "/bin")

	Utility.CreateDirIfNotExist(path + "/bin")

	err = Utility.CopyDir(dir+"/bin/.", path+"/bin")
	if err != nil {
		log.Panicln("--> fail to copy bin ", err)
	}

	// Change the files permission to add execute write.
	files, err := ioutil.ReadDir(path + "/bin")
	if err != nil {
		log.Fatal(err)
	}

	// Now I will copy the prototype files of the internal gRPC service
	// admin, resource, ca and services.
	serviceDir := os.Getenv("GLOBULAR_SERVICES_ROOT")
	Utility.CreateDirIfNotExist(path + "/proto")
	err = Utility.CopyFile(serviceDir+"/proto/admin.proto", path+"/proto/admin.proto")
	if err != nil {
		log.Println("fail to copy with error ", err)
	}
	err = Utility.CopyFile(serviceDir+"/proto/ca.proto", path+"/proto/ca.proto")
	if err != nil {
		log.Println("fail to copy with error ", err)
	}
	err = Utility.CopyFile(serviceDir+"/proto/resource.proto", path+"/proto/resource.proto")
	if err != nil {
		log.Println("fail to copy with error ", err)
	}
	err = Utility.CopyFile(serviceDir+"/proto/packages.proto", path+"/proto/packages.proto")
	if err != nil {
		log.Println("fail to copy with error ", err)
	}
	err = Utility.CopyFile(serviceDir+"/proto/lb.proto", path+"/proto/lb.proto")
	if err != nil {
		log.Println("fail to copy with error ", err)
	}

	for _, f := range files {
		if !f.IsDir() {
			err = os.Chmod(path+"/bin/"+f.Name(), 0755)
			if err != nil {
				fmt.Println(err)
			}
		}
	}

	// install services...
	for _, s := range g.getServices() {
		id := getStringVal(s, "Id")
		_, hasName := s.Load("Name")
		if hasName {
			name := getStringVal(s, "Name")

			// I will read the configuration file to have nessecary service information
			// to be able to create the path.
			configPath := getStringVal(s, "Path")
			if len(configPath) > 0 {
				configPath = configPath[:strings.LastIndex(configPath, "/")] + "/config.json"
				if Utility.Exists(configPath) {
					log.Println("install service ", name)
					bytes, err := ioutil.ReadFile(configPath)
					config := make(map[string]interface{}, 0)
					json.Unmarshal(bytes, &config)

					if err == nil {
						_, hasProto := s.Load("Proto")
						_, hasPath := s.Load("Path")
						// set the name.
						if config["PublisherId"] != nil && config["Version"] != nil && hasPath && hasProto {

							execPath := getStringVal(s, "Path")
							protoPath := getStringVal(s, "Proto")

							if Utility.Exists(execPath) && Utility.Exists(protoPath) {
								var serviceDir = "services/"
								if len(config["PublisherId"].(string)) == 0 {
									serviceDir += config["Domain"].(string) + "/" + name + "/" + config["Version"].(string)
								} else {
									serviceDir += config["PublisherId"].(string) + "/" + name + "/" + config["Version"].(string)
								}

								lastIndex := strings.LastIndex(execPath, "/")
								if lastIndex == -1 {
									lastIndex = strings.LastIndex(execPath, "/")
								}

								execName := execPath[lastIndex+1:]
								destPath := path + "/" + serviceDir + "/" + id + "/" + execName

								if Utility.Exists(execPath) {
									Utility.CreateDirIfNotExist(path + "/" + serviceDir + "/" + id)

									err := Utility.Copy(execPath, destPath)
									if err != nil {
										log.Panicln(execPath, destPath, err)
									}

									// Set execute permission
									err = os.Chmod(destPath, 0755)
									if err != nil {
										fmt.Println(err)
									}

									config["Path"] = destPath
									config["Proto"] = path + "/" + serviceDir + "/" + name + ".proto"

									// set the security values to nothing...
									config["CertAuthorityTrust"] = ""
									config["CertFile"] = ""
									config["KeyFile"] = ""
									config["TLS"] = false

									str, _ := Utility.ToJson(&config)
									ioutil.WriteFile(path+"/"+serviceDir+"/"+id+"/config.json", []byte(str), 0644)

									// Copy the proto file.
									if Utility.Exists(protoPath) {
										Utility.Copy(protoPath, config["Proto"].(string))
									}

								} else {
									fmt.Println("executable not exist ", execPath)
								}
							} else if !Utility.Exists(execPath) {
								log.Println("no executable found at path " + execPath)
							} else if !Utility.Exists(protoPath) {
								log.Println("no proto file found at path " + protoPath)
							}
						} else if config["PublisherId"] == nil {
							fmt.Println("no publisher was define!")
						} else if config["Version"] == nil {
							fmt.Println("no version was define!")
						} else if !hasProto {
							fmt.Println(" no proto file was found!")
						} else if !hasPath {
							fmt.Println("no executable was found!")
						}
					} else {
						fmt.Println(err)
					}
				} else {
					fmt.Println("service", name, ":", id, "configuration is incomplete!")
				}
			} else {

				// Internal services here.
				protoPath := getStringVal(s, "Proto")
				// Copy the proto file.
				if Utility.Exists(os.Getenv("GLOBULAR_SERVICES_ROOT") + "/" + protoPath) {
					Utility.Copy(os.Getenv("GLOBULAR_SERVICES_ROOT")+"/"+protoPath, path+"/"+protoPath)
				}
			}
		}
	}

	dockerfile += `WORKDIR /globular
	ENTRYPOINT ["/globular/Globular"]`

	// save docker.
	err = ioutil.WriteFile(path+"/Dockerfile", []byte(dockerfile), 0644)
	if err != nil {
		log.Println(err)
	}